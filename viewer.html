<!doctype html>
<html lang="en">
    <head>
        <title>SSL Veiwer</title>
        <script type="text/javascript">
            const fieldWidth = 1040;
            const fieldHeight = 740;

            function canvas_arrow(context, fromx, fromy, tox, toy) {
                var headlen = 10; // length of head in pixels
                var dx = tox - fromx;
                var dy = toy - fromy;
                var angle = Math.atan2(dy, dx);
                context.moveTo(fromx, fromy);
                context.lineTo(tox, toy);
                context.lineTo(
                    tox - headlen * Math.cos(angle - Math.PI / 6),
                    toy - headlen * Math.sin(angle - Math.PI / 6),
                );
                context.moveTo(tox, toy);
                context.lineTo(
                    tox - headlen * Math.cos(angle + Math.PI / 6),
                    toy - headlen * Math.sin(angle + Math.PI / 6),
                );
            }

            function fixCanvasHighPixelDensity(canvas, ctx) {
                // fix blur on high pixel density screens https://stackoverflow.com/a/59143499
                const sizeX = 1040;
                const sizeY = 740;
                canvas.style.width = sizeX + "px";
                canvas.style.height = sizeY + "px";

                // Set actual size in memory (scaled to account for extra pixel density).
                const scale = window.devicePixelRatio; // Change to 1 on retina screens to see blurry canvas.
                canvas.width = sizeX * scale;
                canvas.height = sizeY * scale;

                // Normalize coordinate system to use css pixels.
                ctx.scale(scale, scale);
            }

            function renderField(ctx) {
                // set pen width
                ctx.lineWidth = 1;

                // div B field from https://robocup-ssl.github.io/ssl-rules/sslrules.html
                // background
                ctx.fillStyle = "green";
                ctx.fillRect(0, 0, fieldWidth, fieldHeight);

                // black square
                ctx.lineWidth = 4;
                ctx.strokeStyle = "black";
                ctx.strokeRect(40, 40, 960, 660);

                // white outer rect
                ctx.lineWidth = 1;
                ctx.strokeStyle = "white";
                ctx.strokeRect(70, 70, 900, 600);

                // white center circle
                ctx.beginPath();
                ctx.ellipse(
                    1040 / 2,
                    740 / 2,
                    50,
                    50,
                    Math.PI / 4,
                    0,
                    2 * Math.PI,
                );
                ctx.stroke();

                // white vertical line
                ctx.moveTo(1040 / 2, 70);
                ctx.lineTo(1040 / 2, 670);
                ctx.stroke();
                // white horizontal line
                ctx.moveTo(70, 740 / 2);
                ctx.lineTo(970, 740 / 2);
                ctx.stroke();

                // white left defense area
                ctx.strokeRect(70, 740 / 2 - 100, 100, 200);

                // white right defense area
                ctx.strokeRect(970 - 100, 740 / 2 - 100, 100, 200);

                // white left goal
                ctx.strokeRect(70 - 18, 740 / 2 - 50, 18, 100);
                // white right goal
                ctx.strokeRect(970, 740 / 2 - 50, 18, 100);
            }

            function renderRobot(ctx, robotRenderCommandData) {
                let color;
                switch (robotRenderCommandData.color) {
                    case "Blue":
                        color = "blue";
                        break;
                    case "Yellow":
                        color = "yellow";
                        break;
                    default:
                        console.log(
                            "unknown color",
                            robotRenderCommandData.color,
                        );
                        return;
                }
                if (robotRenderCommandData.has_ball) {
                    color = "purple";
                }

                const pos_x =
                    robotRenderCommandData.pos.x * 100 + fieldWidth / 2;
                const pos_y =
                    -robotRenderCommandData.pos.y * 100 + fieldHeight / 2;

                const vel_x = robotRenderCommandData.vel.x * 100;
                const vel_y = -robotRenderCommandData.vel.y * 100;

                ctx.lineWidth = 1;
                ctx.fillStyle = color;
                ctx.strokeStyle = color;

                // vel vector
                ctx.beginPath();
                canvas_arrow(ctx, pos_x, pos_y, pos_x + vel_x, pos_y + vel_y);
                ctx.stroke();

                // robot circle
                ctx.beginPath();
                ctx.arc(pos_x, pos_y, 9, 0, 2 * Math.PI);
                ctx.fill();

                // robot id
                const textColor = color == "blue" ? "white" : "black";
                ctx.fillStyle = textColor;
                ctx.strokeStyle = textColor;
                ctx.font = "13px serif";
                ctx.fillText(robotRenderCommandData.id, pos_x - 3, pos_y + 4); // magic offsets to center the id inside the robot
            }

            function renderPoint(ctx, pointRenderCommandData) {
                const color = pointRenderCommandData.color;
                const pos_x =
                    pointRenderCommandData.pos.x * 100 + fieldWidth / 2;
                const pos_y =
                    -pointRenderCommandData.pos.y * 100 + fieldHeight / 2;

                ctx.lineWidth = 1;
                ctx.fillStyle = color;
                ctx.strokeStyle = color;

                ctx.beginPath();
                ctx.arc(pos_x, pos_y, 2.5, 0, 2 * Math.PI);
                ctx.fill();
            }

            function render(ctx, renderCommandData) {
                switch (renderCommandData.type) {
                    case "Robot": {
                        renderRobot(ctx, renderCommandData);
                        break;
                    }
                    case "Point": {
                        renderPoint(ctx, renderCommandData);
                        break;
                    }
                }
            }

            function refresh(ctx, objectsToDraw) {
                renderField(ctx);
                for (const o of objectsToDraw) {
                    render(ctx, o);
                }
            }

            window.onload = function () {
                // graphics
                const c = document.getElementById("field");
                const ctx = c.getContext("2d", { alpha: false });
                fixCanvasHighPixelDensity(c, ctx);
                renderField(ctx);

                // comm
                const ws = new WebSocket("ws://127.0.0.1:8282");
                ws.onmessage = (event) => {
                    const cmd = JSON.parse(event.data);
                    requestAnimationFrame(() => refresh(ctx, cmd.objects));
                };
            };
        </script>
    </head>
    <body>
        <canvas id="field" width="1040" height="740"> </canvas>
    </body>
    <style>
        body {
            background-color: #0a0a0a;
        }
    </style>
</html>
